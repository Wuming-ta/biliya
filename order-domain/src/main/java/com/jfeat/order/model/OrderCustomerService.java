/*
 *   Copyright (C) 2014-2016 www.kequandian.net
 *
 *    The program may be used and/or copied only with the written permission
 *    from www.kequandian.net or in accordance with the terms and
 *    conditions stipulated in the agreement/contract under which the program
 *    has been supplied.
 *
 *    All rights reserved.
 *
 */

/*
 * This file is automatically generated by tools.
 * It defines the model for the table. All customize operation should 
 * be written here. Such as query/update/delete.
 * The controller calls this object.
 */
package com.jfeat.order.model;

import com.google.common.collect.Lists;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.jfeat.kit.JsonKit;
import com.jfeat.order.model.base.OrderCustomerServiceBase;
import com.jfinal.ext.plugin.tablebind.TableBind;
import com.jfinal.kit.StrKit;
import com.jfinal.plugin.activerecord.Page;

import java.text.SimpleDateFormat;
import java.util.*;

@TableBind(tableName = "t_order_customer_service")
public class OrderCustomerService extends OrderCustomerServiceBase<OrderCustomerService> {

    private static Gson gson = new GsonBuilder().create();

    private List<OrderCustomerServiceItem> returns = new ArrayList<>();
    private List<OrderCustomerServiceItem> exchanges = new ArrayList<>();


    public enum ServiceType {
        RETURN, //退货退款
        REFUND,  //仅退款
        EXCHANGE  //换货
    }

    /**
     * 退款方式
     */
    public enum RefundWay {
        // 原路退回
        ORIGINAL_PATH,
        // 其他方式
        OTHER_WAY
    }

    public enum Status {
        CREATED {
            @Override
            public boolean transfer(Status status) {
                return status == CREATED
                        || status == CANCELED
                        || status == RETURN_PENDING
                        || status == REFUND_PENDING
                        || status == REFUNDED
                        || status == EXCHANGED;
            }
        },

        RETURN_PENDING {
            @Override
            public boolean transfer(Status status) {
                return status == RETURN_PENDING || status == CANCELED || status == REFUND_PENDING || status == DELIVERING;
            }
        },

        REFUND_PENDING {
            @Override
            public boolean transfer(Status status) {
                return status == REFUND_PENDING || status == REFUNDED;
            }
        },

        DELIVERING {
            @Override
            public boolean transfer(Status status) {
                return status == EXCHANGED;
            }
        },

        REFUNDED,

        EXCHANGED,

        CANCELED;

        public boolean transfer(Status status) {
            return false;
        }

        public boolean handle(OrderCustomerService orderCustomerService) {
            orderCustomerService.setStatus(this.toString());
            return true;
        }
    }

    /**
     * Only use for query.
     */
    public static OrderCustomerService dao = new OrderCustomerService();


    public List<OrderCustomerServiceItem> getReturns() {
        if (returns.isEmpty()) {
            returns = OrderCustomerServiceItem.dao.findByFields(
                    new String[]{OrderCustomerServiceItem.Fields.ORDER_CUSTOMER_SERVICE_ID.toString(), OrderCustomerServiceItem.Fields.TYPE.toString()},
                    new String[]{Integer.toString(getId()), OrderCustomerServiceItem.Type.RETURN.toString()}
            );
        }
        return returns;
    }

    public List<OrderCustomerServiceItem> getExchanges() {
        if (exchanges.isEmpty()) {
            exchanges = OrderCustomerServiceItem.dao.findByFields(
                    new String[]{OrderCustomerServiceItem.Fields.ORDER_CUSTOMER_SERVICE_ID.toString(), OrderCustomerServiceItem.Fields.TYPE.toString()},
                    new String[]{Integer.toString(getId()), OrderCustomerServiceItem.Type.EXCHANGE.toString()}
            );
        }
        return exchanges;
    }

    public Order getOrder() {
        return Order.dao.findById(getOrderId());
    }

    public List<OrderCustomerService> findByOrderId(int orderId) {
        return find("select * from t_order_customer_service where order_id=? order by id desc", orderId);
    }

    public Page<OrderCustomerService> paginate(int pageNumber, int pageSize,
                                               String orderNumber,
                                               String serviceType, String serviceNumber,
                                               String storeId, String storeUserId,
                                               String startTime, String endTime) {
        List<Object> params = Lists.newArrayList();
        String select = "select ocs.*,o.order_number,u.name as user_name, u.phone ";
        StringBuilder builder = new StringBuilder();
        builder.append("from t_order_customer_service as ocs" +
                " left join t_order as o on ocs.order_id=o.id" +
                " left join t_user as u on o.user_id=u.id");
        String cond = " where ";

        if (StrKit.notBlank(serviceType)) {
            builder.append(cond);
            builder.append("ocs.service_type=?");
            params.add(serviceType);
            cond = " and ";
        }

        if (StrKit.notBlank(serviceNumber)) {
            builder.append(cond);
            builder.append("ocs.service_number like ? ");
            params.add(serviceNumber + "%");
            cond = " and ";
        }

        if (StrKit.notBlank(orderNumber)) {
            builder.append(cond);
            builder.append("o.order_number like ? ");
            params.add(orderNumber + "%");
            cond = " and ";
        }

        if (StrKit.notBlank(storeId)) {
            builder.append(cond);
            builder.append("ocs.store_id=?");
            params.add(storeId);
            cond = " and ";
        }

        if (StrKit.notBlank(storeUserId)) {
            builder.append(cond);
            builder.append("ocs.store_user_id=?");
            params.add(storeUserId);
            cond = " and ";
        }

        if (StrKit.notBlank(startTime) && StrKit.notBlank(endTime)) {
            builder.append(cond);
            builder.append("ocs.created_date between ? and ?");
            params.add(startTime);
            params.add(endTime);
            cond = " and ";
        }

        builder.append(" order by ocs.id desc");

        return paginate(pageNumber, pageSize, select, builder.toString(), params.toArray());

    }

    @Override
    public boolean save() {
        setCreatedDate(new Date());
        setStatus(Status.CREATED.toString());
        super.save();
        StringBuilder serviceNumber = new StringBuilder();
        serviceNumber.append(getOrder().getOrderNumber()).append("-").append(getId());
        setServiceNumber(serviceNumber.toString());
        return super.update();
    }

    public void addLog(String operator, String content) {
        List<Map<String, Object>> logList = getLogToListMap();
        Map<String, Object> log = new HashMap<>();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        log.put("user", operator);
        log.put("time", simpleDateFormat.format(new Date()));
        log.put("content", content);
        logList.add(log);
        setListMapToLog(logList);
    }

    public void setListToImages(List<String> imageList) {
        String imagesJson = com.jfinal.kit.JsonKit.toJson(imageList);
        if (imageList == null) {
            imagesJson = "[]";
        }
        setImages(imagesJson);
    }

    public List<String> getImagesToList() {
        return gson.fromJson(getImages(), List.class);
    }

    public List<Map<String, Object>> getLogToListMap() {
        try {
            if (StrKit.notBlank(getLog())) {
                Map<String, Object>[] logMap = JsonKit.convertToMapArray(getLog());
                return Lists.newArrayList(logMap);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Lists.newArrayList();
    }

    public void setListMapToLog(List<Map<String, Object>> logList) {
        setLog(com.jfinal.kit.JsonKit.toJson(logList));
    }
}
